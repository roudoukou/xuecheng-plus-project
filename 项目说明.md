
## 环境准备
IDEA 中的字符编码集都选择是UTF8

将解压的虚拟机进行赋值, 不选择移动

虚拟机账号密码 root / centos

mysql中的账号密码 root / mysql

gogs的账号密码 gogs / gogs

启动docker
```bash
systemctl start docker
sh /data/soft/restart.sh
```

将数据导入到数据库中, 使用代码生成器, 创建po类

添加swagger依赖 , 然后进行测试http://localhost:63040/content/swagger-ui.html

添加config的配置类, `LocalDateTimeConfig`, 将日期进行展示`yyyy-MM-dd HH:mm:ss`格式
"createDate": "2023-06-25 20:36:45",

拷贝代码生成器生成的mapper到service

创建数据字典表

使用 http client 插件进行接口测试

部署前端工程 和 系统管理服务

使用全局Cors过滤器, 解决前端工程的跨域问题

前端工程还没提交代码

编写mapper, 查询category树形结构类型的数据, 然后测试

自连接的sql语句
```sql
SELECT one.id, one.label, two.id, two.label
FROM course_category `one`
JOIN course_category two
ON two.parentid = one.id
WHERE one.parentid = '1'
AND one.is_show = '1'
AND two.is_show = '1'
ORDER BY one.orderby, two.orderby

WITH recursive t1 AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n+1 FROM t1 WHERE n<5
)
SELECT * FROM t1

-- 向上递归
WITH recursive t1 AS (
  SELECT * FROM course_category WHERE id = '1'
  UNION ALL 
  SELECT t2.* FROM course_category t2 JOIN t1 ON t1.id = t2.parentid
)
SELECT * FROM t1 ORDER BY t1.id

-- 向上递归
WITH recursive t1 AS (
  SELECT * FROM course_category WHERE id = '1-1-1'
  UNION ALL
  SELECT t2.* FROM course_category t2 INNER JOIN t1 ON t1.parentid = t2.id
)
SELECT * FROM t1 ORDER BY t1.id
```

课程分类查询

## dev03

使用JSR303校验参数是否为空
在实体对象上添加注解 `@NotEmpty` , 然后再Controller接收参数使用`@Validated`激活
当增删改共用一个对象时, 还需要抛出不同的信息内容, 这时需要定义一个分组接口
注解内部 `@Validated` 需要指定下是用的哪个分组

```java
public CourseBaseInfoDto createCourseBase(
    @RequestBody @Validated(ValidationGroups.Insert.class) AddCourseDto addCourseDto){
    ...        
}
```

```java
/**
 * 校验分组
 */
public class ValidationGroups {

    public interface Insert{};
    public interface Update{};
    public interface Delete{};

}
```

修改课程, 先按照courseid查询出当前接口

## 关于mybatis
插入语句之后返回主键
首先数据库的主键要自动递增
然后再insert标签上添加`useGeneratedKeys="true" keyProperty="id"`
```xml
    <!--Integer addCourseTeacher(CourseTeacher courseTeacher);-->
    <insert id="addCourseTeacher" useGeneratedKeys="true" keyProperty="id">
        insert into course_teacher(course_id,
                                   teacher_name,
                                   position,
                                   introduction)
        values(#{courseId},
               #{teacherName},
               #{position},
               #{introduction})
    </insert>
```

插入之后, 主键返回在传入的对象当中
```java
        Integer integer = courseTeacherMapper.addCourseTeacher(courseTeacher);
        // 影响的行数
        System.out.println("integer = " + integer);
        // 返回的主键
        System.out.println(courseTeacher.getId());
```

### 各种返回值
insert：插入n条记录，返回影响行数n。（n>=1，n为0时实际为插入失败）
update：更新n条记录，返回影响行数n。（n>=0）
delete：删除n条记录，返回影响行数n。（n>=0）
参考: https://www.cnblogs.com/aspirant/p/12213428.html

待完成: 通过远程调用传入字典值, 获取code


### 配置本地优先
在nacos中配置override-none, 然后让微服务读取这个配置
```yaml
server:
  servlet:
    context-path: /content
  port: 63040
# 配置本地优先
spring:
  cloud:
    config:
      override-none: true
  # datasource:
  #   driver-class-name: com.mysql.cj.jdbc.Driver
  #   url: jdbc:mysql://192.168.101.65:3306/xc402_content?serverTimezone=UTC&userUnicode=true&useSSL=false&
  #   username: root
  #   password: mysql
```

本地运行添加这个参数, 就会按照63041端口运行微服务
-Dserver.port=63041

同样可以添加一个参数用来切换不同环境`-Dserver.port=63041 spring.profiles.active=test`

## 事务优化

一个普通方法(非事务方法)调用一个事务方法, 此时的事务会失效
```java
@Service
public class MediaFileServiceImpl implements MediaFileService {
    
    @Autowired
    MediaFileService mediaFileService;

    /**
     * 普通方法
     */
    public UploadFileResultDto uploadFile() {
        // 不会回滚
        // MediaFiles mediaFiles = addMediaFilesToDb();
        // 不会回滚
        // MediaFiles mediaFiles = this.addMediaFilesToDb();
        
        // 事务控制必须是代理对象调用才有效果, 将自己注入给自己
        // 这个`mediaFileService`就是一个代理对象, 此时调用的方法出现异常会进行事务的回滚
        MediaFiles mediaFiles = mediaFileService.addMediaFilesToDb(); 
    }

    /**
     * 事务方法
     * @return
     */
    @Transactional
    public MediaFiles addMediaFilesToDb(){
        // 进行数据库的操作
        // ...
        
        // 异常
        int i = 1/0;
    }
}
```

事务控制必须是代理对象调用才有效果

## 任务调度中心
http://192.168.101.65:8088/xxl-job-admin

admin
123456

在使用任务调度的时候, 需要在配置中心将appname指定好
```yml
xxl:
  job:
    admin: 
      addresses: http://192.168.101.65:8088/xxl-job-admin
    executor:
      appname: coursepublish-job
      address: 
      ip: 
      port: 8999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
    accessToken: default_token
```
然后在`执行器管理`中创建对应的appname
接着在 `任务管理` 中可以创建一些定时任务

在需要执行定时调度任务的方法上添加注解 `@XxlJob`
```java
    //任务调度入口
    @XxlJob("CoursePublishJobHandler")
    public void coursePublishJobHandler() throws Exception {}
```


## 要注意的一点, service中的配置, 使用的数据库并不是最新的数据库, 现在暂时还没有全部修改

## 关于test测试
![/assets/img.png](assets/img.png)

这个service模块是没有启动类的, 如果想在这下面使用@Test进行代码测试, 需要创建出来对应的启动类, 否则无法测试

乐观锁, 不用先拿到锁, 尽管去执行, 执行失败了, 接着重试再执行
悲观锁, 要先拿到锁

![/assets/img_1.png](assets/img_1.png)


## nginx部署门户
启动nginx
```bash
.\nginx.exe
```

修改配置后重新加载nginx
```bash
./nginx.exe -s reload
```

tips: nginx的安装目录不能在有中文的路径下
但是请求访问的静态资源的路径是可以存在中文的

事务的特性ACID

atomicity

consistency

isolation

durability

CAP理论
Consistency             一致性

Availability            可用性

Partition tolerance     分区容忍性

AP的处理方式:
采用消息表＋定时任务调度

## nginx代理

模板引擎就是服务端渲染
可以将渲染出来的html页面存储到minio, 当有用户来访问的时候直接从minio中读取该html静态资源, 减少服务器压力
部署完成之后访问地址:
http://192.168.101.65:9000/mediafiles/course/120.html

采用文件域名访问
http://file.51xuecheng.cn/mediafiles/course/120.html

主站域名访问
http://www.51xuecheng.cn/course/120.html

只有访问主站的静态资源才会加载css等其他的静态资源, 所以要对nginx进行设置代理
请求了 `www.51xuecheng.cn/course` 之后, 给他代理给 `file.51xuecheng.cn/mediafiles/course`

```text
    server {
        listen       80;
        server_name  www.51xuecheng.cn localhost;
        location /course/ {  
        proxy_pass http://fileserver/mediafiles/course/;
        } 
    }
```


## Kibana无法启动

Kibana server is not ready yet

curl -XDELETE localhost:9200/.kibana_task_manager_7.12.1_001

之后重启elasticsearch和kibana