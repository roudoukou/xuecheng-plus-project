
## 环境准备
IDEA 中的字符编码集都选择是UTF8

将解压的虚拟机进行赋值, 不选择移动

虚拟机账号密码 root / centos

mysql中的账号密码 root / mysql

gogs的账号密码 gogs / gogs

启动docker
```bash
systemctl start docker
sh /data/soft/restart.sh
```

将数据导入到数据库中, 使用代码生成器, 创建po类

添加swagger依赖 , 然后进行测试http://localhost:63040/content/swagger-ui.html

添加config的配置类, `LocalDateTimeConfig`, 将日期进行展示`yyyy-MM-dd HH:mm:ss`格式
"createDate": "2023-06-25 20:36:45",

拷贝代码生成器生成的mapper到service

创建数据字典表

使用 http client 插件进行接口测试

部署前端工程 和 系统管理服务

使用全局Cors过滤器, 解决前端工程的跨域问题

前端工程还没提交代码

编写mapper, 查询category树形结构类型的数据, 然后测试

自连接的sql语句
```sql
SELECT one.id, one.label, two.id, two.label
FROM course_category `one`
JOIN course_category two
ON two.parentid = one.id
WHERE one.parentid = '1'
AND one.is_show = '1'
AND two.is_show = '1'
ORDER BY one.orderby, two.orderby

WITH recursive t1 AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n+1 FROM t1 WHERE n<5
)
SELECT * FROM t1

-- 向上递归
WITH recursive t1 AS (
  SELECT * FROM course_category WHERE id = '1'
  UNION ALL 
  SELECT t2.* FROM course_category t2 JOIN t1 ON t1.id = t2.parentid
)
SELECT * FROM t1 ORDER BY t1.id

-- 向上递归
WITH recursive t1 AS (
  SELECT * FROM course_category WHERE id = '1-1-1'
  UNION ALL
  SELECT t2.* FROM course_category t2 INNER JOIN t1 ON t1.parentid = t2.id
)
SELECT * FROM t1 ORDER BY t1.id
```

课程分类查询

## dev03

使用JSR303校验参数是否为空
在实体对象上添加注解 `@NotEmpty` , 然后再Controller接收参数使用`@Validated`激活
当增删改共用一个对象时, 还需要抛出不同的信息内容, 这时需要定义一个分组接口
注解内部 `@Validated` 需要指定下是用的哪个分组

```java
public CourseBaseInfoDto createCourseBase(
    @RequestBody @Validated(ValidationGroups.Insert.class) AddCourseDto addCourseDto){
    ...        
}
```

```java
/**
 * 校验分组
 */
public class ValidationGroups {

    public interface Insert{};
    public interface Update{};
    public interface Delete{};

}
```

修改课程, 先按照courseid查询出当前接口

## 关于mybatis
插入语句之后返回主键
首先数据库的主键要自动递增
然后再insert标签上添加`useGeneratedKeys="true" keyProperty="id"`
```xml
    <!--Integer addCourseTeacher(CourseTeacher courseTeacher);-->
    <insert id="addCourseTeacher" useGeneratedKeys="true" keyProperty="id">
        insert into course_teacher(course_id,
                                   teacher_name,
                                   position,
                                   introduction)
        values(#{courseId},
               #{teacherName},
               #{position},
               #{introduction})
    </insert>
```

插入之后, 主键返回在传入的对象当中
```java
        Integer integer = courseTeacherMapper.addCourseTeacher(courseTeacher);
        // 影响的行数
        System.out.println("integer = " + integer);
        // 返回的主键
        System.out.println(courseTeacher.getId());
```

### 各种返回值
insert：插入n条记录，返回影响行数n。（n>=1，n为0时实际为插入失败）
update：更新n条记录，返回影响行数n。（n>=0）
delete：删除n条记录，返回影响行数n。（n>=0）
参考: https://www.cnblogs.com/aspirant/p/12213428.html

待完成: 通过远程调用传入字典值, 获取code


### 配置本地优先
在nacos中配置override-none, 然后让微服务读取这个配置
```yaml
server:
  servlet:
    context-path: /content
  port: 63040
# 配置本地优先
spring:
  cloud:
    config:
      override-none: true
  # datasource:
  #   driver-class-name: com.mysql.cj.jdbc.Driver
  #   url: jdbc:mysql://192.168.101.65:3306/xc402_content?serverTimezone=UTC&userUnicode=true&useSSL=false&
  #   username: root
  #   password: mysql
```

本地运行添加这个参数, 就会按照63041端口运行微服务
-Dserver.port=63041

同样可以添加一个参数用来切换不同环境`-Dserver.port=63041 spring.profiles.active=test`

## 事务优化

一个普通方法(非事务方法)调用一个事务方法, 此时的事务会失效
```java
@Service
public class MediaFileServiceImpl implements MediaFileService {
    
    @Autowired
    MediaFileService mediaFileService;

    /**
     * 普通方法
     */
    public UploadFileResultDto uploadFile() {
        // 不会回滚
        // MediaFiles mediaFiles = addMediaFilesToDb();
        // 不会回滚
        // MediaFiles mediaFiles = this.addMediaFilesToDb();
        
        // 事务控制必须是代理对象调用才有效果, 将自己注入给自己
        // 这个`mediaFileService`就是一个代理对象, 此时调用的方法出现异常会进行事务的回滚
        MediaFiles mediaFiles = mediaFileService.addMediaFilesToDb(); 
    }

    /**
     * 事务方法
     * @return
     */
    @Transactional
    public MediaFiles addMediaFilesToDb(){
        // 进行数据库的操作
        // ...
        
        // 异常
        int i = 1/0;
    }
}
```

事务控制必须是代理对象调用才有效果


